(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{295:function(a,n,t){"use strict";t.r(n);var s=t(13),r=Object(s.a)({},(function(){var a=this,n=a._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h1",{attrs:{id:"项目结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#项目结构"}},[a._v("#")]),a._v(" 项目结构")]),a._v(" "),n("p",[a._v("Go 目前并没有官方的项目结构，我们可以参考社区的常用结构")]),a._v(" "),n("h2",{attrs:{id:"可执行项目-应用-结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#可执行项目-应用-结构"}},[a._v("#")]),a._v(" 可执行项目（应用）结构")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("exe-layout\n├── cmd/\n│     ├──app1/\n│     │    └── main.go\n│     └──app2/\n│          └── main.go\n├── go.mod\n├── go.sum\n├── internal/\n│     ├── pkga/\n│     │    └── pkg_a.go\n│     └── pkgb/\n│          └── pkg_b.go\n├── pkg1/\n│    └── pkg1.go\n├── pkg2/\n│    └── pkg2.go\n└── vendor/\n")])])]),n("h2",{attrs:{id:"库项目结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#库项目结构"}},[a._v("#")]),a._v(" 库项目结构")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("lib-layout\n│\n├── go.mod\n├── go.sum\n├── internal/\n│     ├── pkga/\n│     │    └── pkg_a.go\n│     └── pkgb/\n│          └── pkg_b.go\n├── pkg1/\n│    └── pkg1.go\n└── pkg2/\n     └── pkg2.go\n")])])]),n("h2",{attrs:{id:"目录解释"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#目录解释"}},[a._v("#")]),a._v(" 目录解释")]),a._v(" "),n("ul",[n("li",[n("strong",[a._v("cmd 目录")]),a._v(": 存放项目要编译构建的可执行文件所对应的 main 包的源码文件；")]),a._v(" "),n("li",[n("strong",[a._v("项目包(pkgN)")]),a._v(": 每个项目下的非 main 包都“平铺”在项目的根目录下，每个目录对应一个 Go 包；")]),a._v(" "),n("li",[n("strong",[a._v("internal 目录")]),a._v("：存放仅项目内部引用的 Go 包，这些包无法被项目之外引用；")]),a._v(" "),n("li",[n("strong",[a._v("vendor 目录")]),a._v("：这是一个可选目录，为了兼容 Go 1.5 引入的 vendor 构建模式而存在的。这个目录下的内容均由 Go 命令自动维护，不需要开发者手工干预。")])])])}),[],!1,null,null,null);n.default=r.exports}}]);