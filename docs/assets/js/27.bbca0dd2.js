(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{294:function(t,a,s){"use strict";s.r(a);var e=s(13),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"自定义类型-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义类型-type"}},[t._v("#")]),t._v(" 自定义类型/Type")]),t._v(" "),a("p",[t._v("虽然 Go 内置给我们定义了一系列的数据类型， 但在开发的时候，我们总希望可以有更多的复合结构选择。 因此 Go 为我们提供了可以自定义数据类型的途径。")]),t._v(" "),a("h2",{attrs:{id:"定义一个新类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义一个新类型"}},[t._v("#")]),t._v(" 定义一个新类型")]),t._v(" "),a("p",[t._v("我们可以通过"),a("code",[t._v("type")]),t._v("关键字，定义我们自己的类型")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义一个叫 myType 的类型，他的底层类型是int")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" myType "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n")])])]),a("h2",{attrs:{id:"新定义的类型可以被二次利用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新定义的类型可以被二次利用"}},[t._v("#")]),t._v(" 新定义的类型可以被二次利用")]),t._v(" "),a("p",[t._v("通过"),a("code",[t._v("type")]),t._v("定义的类型，可以被"),a("code",[t._v("type")]),t._v("二次利用")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" myType "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" anotherType myType\n")])])]),a("h2",{attrs:{id:"底层类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#底层类型"}},[t._v("#")]),t._v(" 底层类型")]),t._v(" "),a("p",[t._v("前面代码注释中，我们提到了一个名词——“底层类型”。")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" myType "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" anotherType myType\n")])])]),a("p",[t._v("在这个例子中，"),a("code",[t._v("mytype")]),t._v("的底层类型就是"),a("code",[t._v("int")]),t._v("。而"),a("code",[t._v("anotherType")]),t._v("虽然继承于"),a("code",[t._v("myType")]),t._v("但，由于不是Go的原生类型，所以会继续往下找。直到找到"),a("code",[t._v("int")]),t._v("。因此"),a("code",[t._v("myType")]),t._v(" 和"),a("code",[t._v("anotherType")]),t._v("的底层类型都是"),a("code",[t._v("int")]),t._v("。这种情况下，我们认为这两个类型是一样的。"),a("br"),t._v("\n记住：底层类型在 Go 语言中有重要作用，它被用来判断两个类型本质上是否相同（Identical）。")]),t._v(" "),a("h2",{attrs:{id:"显式转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#显式转换"}},[t._v("#")]),t._v(" 显式转换")]),t._v(" "),a("p",[t._v("如果两个类型本质相同，Go 会允许他们的变量可以进行显式转换。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('type myType int\ntype anotherType myType\ntype S string\n\nfunc main(){\n\tvar m1 myType\n\tvar m2 anotherType = 5\n\tm1 = myType(m2) // 允许显式转换\n\n\tvar s S = "hello"\n\tm1 = myType(s) // 错误：cannot converts (S) to myType\n}\n')])])]),a("h2",{attrs:{id:"定义复合类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义复合类型"}},[t._v("#")]),t._v(" 定义复合类型")]),t._v(" "),a("p",[t._v("当然前面讲的定义原生类型就太小儿科了，"),a("code",[t._v("type")]),t._v("真正的常用场景是定义复合类型")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" M "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" S "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n")])])]),a("h2",{attrs:{id:"类型别名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类型别名"}},[t._v("#")]),t._v(" 类型别名")]),t._v(" "),a("p",[t._v("还有一个用法是给已有的类型起别名。")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// aType太复杂，我们给他一个别名T")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" T aType\n")])])]),a("h2",{attrs:{id:"块式定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#块式定义"}},[t._v("#")]),t._v(" 块式定义")]),t._v(" "),a("p",[t._v("与"),a("code",[t._v("var")]),t._v("一样，"),a("code",[t._v("type")]),t._v("支持块方式批量定义类型")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n\tT1 "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n\tT2 T1\n\tT3 "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);